#pragma kernel SampleDepthPoints

Texture2DArray<float> _EnvironmentDepthTexture;
SamplerState sampler_EnvironmentDepthTexture;
float4x4 _EnvironmentDepthReprojectionMatrices[2];
float4 _EnvironmentDepthZBufferParams;

float3 _CameraPosition;
float3 _CameraForward;
float3 _CameraRight;
float3 _CameraUp;
float _TanHalfFOV;
float _AspectRatio;

struct DepthSampleResult
{
    float3 worldPosition;
    float depth;
    float isValid;
};

RWStructuredBuffer<DepthSampleResult> _ResultBuffer;
RWStructuredBuffer<float2> _InputUVs;

float SampleEnvironmentDepthLinear(float2 uv, uint eyeIndex)
{
    float inputDepthEye = _EnvironmentDepthTexture.SampleLevel(sampler_EnvironmentDepthTexture, float3(uv, (float) eyeIndex), 0).r;
    float inputDepthNdc = inputDepthEye * 2.0 - 1.0;
    
    if (inputDepthNdc >= 1.0f)
    {
        return 10000.0;
    }
    
    float linearDepth = (1.0 / (inputDepthNdc + _EnvironmentDepthZBufferParams.y)) * _EnvironmentDepthZBufferParams.x;
    return linearDepth;
}

[numthreads(64, 1, 1)]
void SampleDepthPoints(uint3 id : SV_DispatchThreadID)
{
    _ResultBuffer[id.x].worldPosition = float3(0, 0, 0);
    _ResultBuffer[id.x].depth = -1.0;
    _ResultBuffer[id.x].isValid = 0.0;
    
    float2 screenUV = _InputUVs[id.x];
    
    float2 ndc = screenUV * 2.0 - 1.0;
    ndc.y *= -1.0;
    
    float3 viewDir = normalize(
        _CameraForward +
        ndc.x * _TanHalfFOV * _AspectRatio * _CameraRight +
        ndc.y * _TanHalfFOV * _CameraUp
    );
    
    // ⚠️ 修改點: 根據 UV 的 X 座標決定使用哪隻眼睛
    // Quest 使用 Single Pass Instanced 時,左眼在左半邊 (x < 0.5),右眼在右半邊 (x >= 0.5)
    uint eyeIndex = screenUV.x < 0.5 ? 0 : 1;
    
    // ⚠️ 修改點: 對於右眼,需要重新映射 UV 到 0-1 範圍
    float2 adjustedUV = eyeIndex == 0 ? float2(screenUV.x * 2.0, screenUV.y) : float2((screenUV.x - 0.5) * 2.0, screenUV.y);
    
    float guessDepth = 1.0;
    float3 guessWorldPos = _CameraPosition + viewDir * guessDepth;
    
    float4 depthSpace = mul(_EnvironmentDepthReprojectionMatrices[eyeIndex], float4(guessWorldPos, 1.0));
    float2 depthUV = (depthSpace.xy / depthSpace.w + 1.0) * 0.5;
    
    if (any(depthUV < 0.0) || any(depthUV > 1.0))
    {
        return;
    }
    
    float realDepth = SampleEnvironmentDepthLinear(depthUV, eyeIndex);
    
    if (realDepth > 100.0)
    {
        return;
    }
    
    float3 worldPos = _CameraPosition + viewDir * realDepth;
    
    _ResultBuffer[id.x].worldPosition = worldPos;
    _ResultBuffer[id.x].depth = realDepth;
    _ResultBuffer[id.x].isValid = 1.0;
}