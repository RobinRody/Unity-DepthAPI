#pragma kernel SampleDepthPoints

Texture2DArray<float> _EnvironmentDepthTexture;
SamplerState sampler_EnvironmentDepthTexture;
float4 _EnvironmentDepthZBufferParams;

// Depth Camera FOV
float _DepthCameraFovLeft;
float _DepthCameraFovRight;
float _DepthCameraFovTop;
float _DepthCameraFovDown;

// Depth Camera Pose (from DepthFrameDesc.createPose)
float3 _DepthCameraPoseLocation;
float4 _DepthCameraPoseRotation; // Quaternion (x, y, z, w)

uint _CurrentEyeIndex;

// 🆕 批次處理參數 (支援雙眼分批)
int _SampleOffset;
int _SampleCount;

float _MinWorldHeight;
float _MaxWorldHeight;

// 🆕 深度校正參數
float _EdgeDepthCorrectionEnabled;
float _EdgeCorrectionStartRadius;
float _MaxCorrectionPercentage;
float _CorrectionCurveExponent;

struct DepthSampleResult
{
    float3 worldPosition;
    float depth;
    float isValid;
};

RWStructuredBuffer<DepthSampleResult> _ResultBuffer;
RWStructuredBuffer<float2> _InputUVs;

float SampleEnvironmentDepthLinear(float2 uv, uint eyeIndex)
{
    float inputDepthEye = _EnvironmentDepthTexture.SampleLevel(
        sampler_EnvironmentDepthTexture,
        float3(uv, (float) eyeIndex),
        0
    ).r;
    
    float inputDepthNdc = inputDepthEye * 2.0 - 1.0;
    
    if (inputDepthNdc >= 1.0f)
        return 10000.0;
    
    float linearDepth = (1.0 / (inputDepthNdc + _EnvironmentDepthZBufferParams.y)) *
                        _EnvironmentDepthZBufferParams.x;
    return linearDepth;
}

// 🆕 Quaternion rotation function
float3 RotateVectorByQuaternion(float3 v, float4 q)
{
    // q * v * q^-1
    float3 qVec = float3(q.x, q.y, q.z);
    float3 t = 2.0 * cross(qVec, v);
    return v + q.w * t + cross(qVec, t);
}


// 🆕 啟發式深度校正函數
float CorrectEdgeDepth(float rawDepth, float2 uv)
{
    // 如果未啟用,直接返回原始深度
    if (_EdgeDepthCorrectionEnabled < 0.5)
        return rawDepth;
    
    // 計算到中心 (0.5, 0.5) 的距離
    float2 centered = (uv - 0.5) * 2.0; // 轉換到 [-1, 1]
    float distFromCenter = length(centered); // 0~1.414
    
    // 只校正邊緣區域 (distFromCenter > _EdgeCorrectionStartRadius)
    if (distFromCenter < _EdgeCorrectionStartRadius)
        return rawDepth;
    
    // 計算邊緣因子 (0~1)
    float edgeRange = 1.414 - _EdgeCorrectionStartRadius; // 最大可能距離 - 起始半徑
    float edgeFactor = saturate((distFromCenter - _EdgeCorrectionStartRadius) / edgeRange);
    
    // 應用指數曲線 (可調整激進程度)
    edgeFactor = pow(edgeFactor, _CorrectionCurveExponent);
    
    // 計算校正係數
    // Quest 3 邊緣深度通常被低估,所以增加深度值
    float correctionFactor = 1.0 + edgeFactor * _MaxCorrectionPercentage;
    
    return rawDepth * correctionFactor;
}




[numthreads(64, 1, 1)]
void SampleDepthPoints(uint3 id : SV_DispatchThreadID)
{
    // 🔧 支援批次處理 (雙眼分開 Dispatch)
    uint actualIndex = _SampleOffset + id.x;
    
    if (id.x >= (uint)_SampleCount)
    {
        return;
    }
    
    _ResultBuffer[actualIndex].worldPosition = float3(0, 0, 0);
    _ResultBuffer[actualIndex].depth = -1.0;
    _ResultBuffer[actualIndex].isValid = 0.0;
    
    float2 inputUV = _InputUVs[actualIndex];
    uint eyeIndex = _CurrentEyeIndex;
    
    
    // Step 1: 採樣原始深度
    float rawDepth = SampleEnvironmentDepthLinear(inputUV, eyeIndex);
    
    if (rawDepth > 100.0)
    {
        return;
    }
    
    // 🆕 Step 1.5: 啟發式深度校正
    //float linearDepth = SampleEnvironmentDepthLinear(inputUV, eyeIndex);
    float linearDepth = CorrectEdgeDepth(rawDepth, inputUV);
    
    //if (linearDepth > 100.0)
    //{
    //    return;
    //}
    
    // Step 2: UV → Depth Camera Local Space
    float tanX = lerp(-_DepthCameraFovLeft, _DepthCameraFovRight, inputUV.x);
    float tanY = lerp(-_DepthCameraFovDown, _DepthCameraFovTop, inputUV.y);
    
    float3 depthCameraLocalDir = normalize(float3(tanX, tanY, 1.0));
    float3 depthCameraLocalPos = depthCameraLocalDir * linearDepth;
    
    // Step 3: Local → World (using Pose)
    float3 depthCameraWorldDir = RotateVectorByQuaternion(depthCameraLocalPos, _DepthCameraPoseRotation);
    float3 worldPos = _DepthCameraPoseLocation + depthCameraWorldDir;
    
    // Step 4: Height filtering
    if (worldPos.y < _MinWorldHeight || worldPos.y > _MaxWorldHeight)
    {
        _ResultBuffer[actualIndex].isValid = 0.0;
        return;
    }
    
    // Step 5: Store Result
    _ResultBuffer[actualIndex].worldPosition = worldPos;
    _ResultBuffer[actualIndex].depth = linearDepth;
    _ResultBuffer[actualIndex].isValid = 1.0;
}